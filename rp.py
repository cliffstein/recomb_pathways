# -*- coding: utf-8 -*-
"""V3_cbio_critical_genes_brca_tcga_2012.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1nAjEvarpdTiqeef8xKY0MlAxnSX9wNpJ

Load data into dataframe
"""

import numpy as np

from google.colab import drive
drive.mount('/content/drive',force_remount=True)
import os
os.chdir("drive/My Drive/cbio_data")
!ls

import pandas as pd
# file_name = 'bc_data_mrna_agilent_microarray.txt'
file_name = 'bc_metabric_data_mrna_illumina_microarray.txt'
bc_df = pd.read_csv(file_name,sep='\t',header=(0))

# file_name = 'bc_data_clinical_patient.txt'
file_name = 'bc_metabric_data_clinical_patient.txt'
bc_clinical_df = pd.read_csv(file_name,sep='\t',header=(0)).drop(index=[0,1,2,3])

"""Reference vs pathological data"""

# temp=pd.concat([bc_clinical_df['#Patient Identifier'],pd.to_numeric(bc_clinical_df['Metastasis'], errors='ignore')], axis=1).reset_index()
bc_temp=pd.concat([bc_clinical_df['#Patient Identifier'],pd.to_numeric(bc_clinical_df['Lymph nodes examined positive'], errors='ignore')], axis=1).reset_index()

# pick column/sample names in the rna-seq data that correspond to reference set
bc_ref_data = bc_temp[bc_temp['Lymph nodes examined positive']==0]
bc_ref_cols = [sub for sub in bc_df.columns[2:].tolist() if sub[0:12] in bc_ref_data['#Patient Identifier'].tolist()]

# pick column/sample names in the rna-seq data that correspond to reference set
bc_path_data = bc_temp[bc_temp['Lymph nodes examined positive']>0]
bc_path_cols = [sub for sub in bc_df.columns[2:].tolist() if sub[0:12] in bc_path_data['#Patient Identifier'].tolist()]

"""Nuclear Receptors"""

# NR6A1 has been excluded since it is not part of rectal cancer dataset cf. rc_selected_rows
bc_nuclear_receptors = ['AR', 'ESR1', 'ESR2', 'ESRRA', 'ESRRB', 'ESRRG', 'HNF4A', 'HNF4G', 'NR0B1', 'NR0B2', 'NR1D1', 'NR1D2', 'NR1H2', 'NR1H3', 'NR1H4', 'NR1I2', 'NR1I3', 'NR2C1', 'NR2C2', 'NR2E1', 'NR2E3', 'NR2F1', 'NR2F2', 'NR2F6', 'NR3C1', 'NR3C2', 'NR4A1', 'NR4A2', 'NR4A3', 'NR5A1', 'NR5A2', 'NRF1', 'PGR', 'PPARA', 'PPARD', 'PPARG', 'RARA', 'RARB', 'RARG', 'RORA', 'RORB', 'RORC', 'RXRA', 'RXRB', 'RXRG', 'THRA', 'THRB', 'VDR']

bc_selected_rows = [item for sublist in [bc_df[bc_df['Hugo_Symbol']==e].index.to_list() for e in bc_nuclear_receptors] for item in sublist]

"""Filter selected genes i.e., rows"""

#add indices for ccna1 and ccnd1 if not present already
bc_selected_rows.append(20086)
bc_selected_rows.append(15647)

# reference dataframe

bc_filtered_ref_df=bc_df[bc_ref_cols].iloc[bc_selected_rows]

# pathological dataframe

bc_filtered_path_df=bc_df[bc_path_cols].iloc[bc_selected_rows]

"""Search for indiex of specific cyclins"""

bc_filtered_ref_df.index.get_indexer(bc_df.index[bc_df['Hugo_Symbol']=='CCNA1'])

bc_filtered_ref_df.index.get_indexer(bc_df.index[bc_df['Hugo_Symbol']=='CCND1'])

"""Sort by age and compute diffusivity matrix"""

bc_ref_rna_seq = bc_filtered_ref_df[bc_filtered_ref_df.columns].T.values.tolist()
bc_path_rna_seq = bc_filtered_path_df[bc_filtered_path_df.columns].T.values.tolist()

# assumes input is a list of lists with column 0 being the sample ids and
#column nos.; ccna_pos, ccnd_pos being the indices of ccna1 and ccnd1
bc_ccna_pos=len(bc_nuclear_receptors);
bc_ccnd_pos=len(bc_nuclear_receptors)+1;
def SortByStage(list_):
    cell_age = 100*list_[bc_ccna_pos] - 10*list_[bc_ccnd_pos]
    return cell_age;

bc_ref_rna_seq.sort(key=SortByStage)
bc_path_rna_seq.sort(key=SortByStage)

# compute covariance matrix for increments i.e., diffusivity matrix

def ComputeDiffusivity(rna_seq):
  A=[]
  R=list(map(list, zip(*rna_seq)))
  for i in np.arange(len(R)):
    A.append([x - R[i][j - 1] for j, x in enumerate(R[i])][1:])
  cov_matrix = np.cov(A, bias=True)
  return cov_matrix;

"""Solve sensing problem to recover sparse dynamical system"""

import cvxpy as cvx
import cvxopt

"""
 Compute the Sparse dynamical system underlying the unperturbed DNA replication
"""
def SolveSensingProblem(Sigma, Diffusivity,noise_level=0.01):
  x = cvx.Variable(Sigma.shape)
  ub_constraints=[]
  for j in np.arange(Sigma.shape[0]):
    for i in np.arange(Sigma.shape[0]):
      ub_constraints+=[(Sigma @ x.T)[i,j]+ (x @ Sigma)[i,j] - 2 * Diffusivity[i,j] <= noise_level];
  lb_constraints=[]
  for j in np.arange(Sigma.shape[0]):
    for i in np.arange(Sigma.shape[0]):
      lb_constraints+=[(Sigma @ x.T)[i,j]+ (x @ Sigma)[i,j] - 2 * Diffusivity[i,j] >= -noise_level];
  # optimization problem
  prob = cvx.Problem(cvx.Minimize(cvx.mixed_norm(x,2,1)), ub_constraints+lb_constraints)
  # result = prob.solve(solver=cvx.ECOS, verbose=True)
  result = prob.solve(solver=cvx.SCS, verbose=False, max_iters=5000)
  # Print result.
  print("The optimal value is", prob.value)
  print("A solution x is")
  print(x.value)
  return x.value;

"""Use recovered dynamical system to solve for critical separator genes"""

def ComputeReferenceDistribution(ref_df):
  mu=ref_df.mean(axis=1)
  return mu.tolist();

def ComputeReferenceNoise(ref_df):
  std_dev=ref_df.std(axis=1)
  return std_dev.tolist();

# returns a matrix k \times #genes
def ComputeReferenceDistributionMatrix(ref_df, k):
  r=ComputeReferenceDistribution(ref_df);
  Y=[]
  for i in np.arange(k):
    Y.append(r);
  return np.array(Y);

# returns a matrix #columns(path_df)\times #genes

def ComputePerturbationsToDistribution(path_df, ref_dist):
  if len(path_df.iloc[:,[0]].values.tolist())!=len(ref_dist):
    print("unequal dimensions")
    return 0;
  Y=[]
  for i in np.arange(len(path_df.columns)):
    Y.append((np.array(path_df.iloc[:,[i]].values.tolist()).reshape(len(ref_dist),1)-np.array(ref_dist).reshape(len(ref_dist),1)).flatten().tolist())
  return np.array(Y);

"""
Compute the perturbation in the dynamical system due to disease process
noise_level should be set around std_dev(Diffusivity)/#rows(Diffusivity)
"""
def ComputeCanonicalPerturbation(A, C, Sigma, epsilon=0.01, noise_level=0.01):
  # Define and solve the CVXPY problem.
  prob_size=Sigma.shape[0]
  x = cvx.Variable((prob_size, prob_size))
  ub_constraints=[]
  for j in np.arange(prob_size):
    for i in np.arange(prob_size):
      ub_constraints += [-(Sigma @ x.T)[i,j] - (x @ Sigma)[i,j] + ((A @ C)[i,j] + (C @ A.T)[i,j])/epsilon <= noise_level];
  lb_constraints=[]
  for j in np.arange(prob_size):
    for i in np.arange(prob_size):
      lb_constraints+=[-(Sigma @ x.T)[i,j] - (x @ Sigma)[i,j] + ((A @ C)[i,j] + (C @ A.T)[i,j])/epsilon >= -noise_level];
  prob = cvx.Problem(cvx.Minimize(cvx.norm(cvx.vec(x),1)), ub_constraints+lb_constraints)
  # result = prob.solve(solver=cvx.ECOS, verbose=True)
  result = prob.solve(solver=cvx.SCS, verbose=False, max_iters=5000)
  # Print result.
  print("The optimal value is", prob.value)
  print("A solution x is")
  print(x.value)

  return x.value;

"""Main loop of algorithm

A. Assumes data already preprocessed:
1.   Separate pathological and reference dataframes
2.   Sequentialize data using cyclin expressions

B. Recover underlying dynamical system
"""

# compute covariance matrix for ref and path rna seq data
R=list(map(list, zip(*bc_ref_rna_seq)))
bc_Sigma_ref = np.cov(R, bias=True)
R=list(map(list, zip(*bc_path_rna_seq)))
bc_Sigma_path = np.cov(R, bias=True)

bc_Diffusivity=ComputeDiffusivity(bc_ref_rna_seq)

bc_A = SolveSensingProblem(bc_Sigma_ref, bc_Diffusivity, noise_level=0.1)

import seaborn as sn
import matplotlib.pyplot as plt

plt.figure(figsize=(20, 20))
#colormap=sn.color_palette("vlag", as_cmap=True)
colormap=sn.color_palette("Spectral", as_cmap=True)
A_dim = bc_A.shape[0]-2
hm = sn.heatmap(data = bc_A[0:A_dim,0:A_dim], linewidths=.05,cmap=colormap)
hm.set_xticklabels(bc_df['Hugo_Symbol'].iloc[bc_filtered_ref_df.index][0:A_dim], rotation = 90)
hm.set_yticklabels(bc_df['Hugo_Symbol'].iloc[bc_filtered_ref_df.index][0:A_dim], rotation = 0)

# displaying the plotted heatmap
plt.show()
# from pylab import savefig
# figure = hm.get_figure()
# figure.savefig('v2_nr_system_matrix_brca_tcga_2012.png', dpi=400)

"""C. Compute perturbation of pathological data from reference data


*   Check for inf in filtered_path_df and filtered_ref_df
*   Replace inf by -K, K<< min_value


"""

bc_C = bc_Sigma_path - bc_Sigma_ref
bc_B=ComputeCanonicalPerturbation(bc_A, bc_C, bc_Sigma_ref, epsilon=0.1, noise_level=0.2)

"""D. Plot perturbation heatmap"""

import seaborn as sn
import matplotlib.pyplot as plt

plt.figure(figsize=(20, 20))
colormap=sn.color_palette("Spectral", as_cmap=True)
B_dim = bc_B.shape[0]-2
hm = sn.heatmap(data = 0.1*bc_B[0:B_dim,0:B_dim], linewidths=.05,cmap=colormap)
hm.set_xticklabels(bc_df['Hugo_Symbol'].iloc[bc_filtered_ref_df.index][0:B_dim], rotation = 90)
hm.set_yticklabels(bc_df['Hugo_Symbol'].iloc[bc_filtered_ref_df.index][0:B_dim], rotation = 0)
# displaying the plotted heatmap
plt.show()
#from pylab import savefig
#figure = hm.get_figure()
#figure.savefig('v2_nr_perturb_matrix_brca_tcga_2012.png', dpi=400)

"""Gene network DAG"""

def ComputeCorrForGene(x, y):
  return np.corrcoef(x,y)[0,1]

# input consists of two list of lists, where in both cases each sublist contains a list of rna seq expressions for a given gene
def ComputeCorrs(ref_rna_seqT, path_rna_seqT):
  if len(ref_rna_seqT) != len(path_rna_seqT):
    return [];
  corr_list=[];
  for i in np.arange(len(ref_rna_seqT)):
    x=ref_rna_seqT[i] + path_rna_seqT[i]
    y=[-1 for number in np.arange(len(ref_rna_seqT[i]))] + [1 for number in np.arange(len(path_rna_seqT[i]))]
    corr_list.append(ComputeCorrForGene(x,y))
  return corr_list;

corr_list=ComputeCorrs(list(map(list, zip(*bc_ref_rna_seq))), list(map(list, zip(*bc_path_rna_seq))))

corr_list=ComputeCorrs(list(map(list, zip(*rc_ref_rna_seq))), list(map(list, zip(*rc_path_rna_seq))))

np.abs(bc_C)

# compute digraph where each edge (u,v) has weight corr(u)*C[u,v]
C=np.diag(np.array(corr_list))@bc_B
# C[np.abs(bc_C)<1.1]=0
#C[C<0.95]=0
C[C<0.035]=0

C=np.diag(np.array(corr_list))@rc_B
# C[np.abs(bc_C)<1.1]=0
#C[C<0.95]=0
C[C<0.05]=0

# select "heaviest" K paths from C of length in (l,L) and draw graph
import itertools

l=3;
L=4;
paths=[];
nr_checklist = [2,9,15,21,41]
for i in np.arange(l,L+1):
  for comb in itertools.permutations(np.arange(C.shape[0]), int(i)):
    invalid_path=0
    for j in np.arange(len(comb)-1):
      if C[comb[j+1],comb[j]]==0:
        invalid_path=1
        break;
    # check if the path contains NRs predicted from Lyapunov exponent calculation
    contains_sp_nr=0
    if len(nr_checklist)==0:
        contains_sp_nr=1
    for j in np.arange(len(comb)-1):
      if comb[j] in nr_checklist:
        contains_sp_nr+=1
        break;
    if contains_sp_nr <= 0:
      continue;
    if invalid_path==0:
      paths.append(comb)
# sort paths: heaviest path first

paths

paths = paths[0:5]

import networkx as nx
import matplotlib.pyplot as plt

G = nx.DiGraph()
neg_edge_list=[]
pos_edge_list=[]
neg_nodes_set=set()
pos_nodes_set=set()
neutral_nodes=set()
thresh=0.2
for i in np.arange(min([len(paths),25])):
  for j in np.arange(len(paths[i])-1):
    G.add_edge(bc_nuclear_receptors[paths[i][j]], bc_nuclear_receptors[paths[i][j+1]])
    if bc_B[paths[i][j+1], paths[i][j]] < 0:
      neg_edge_list.append((bc_nuclear_receptors[paths[i][j]], bc_nuclear_receptors[paths[i][j+1]]))
    else:
      pos_edge_list.append((bc_nuclear_receptors[paths[i][j]], bc_nuclear_receptors[paths[i][j+1]]))
    if corr_list[paths[i][j]] < 0:
      if abs(corr_list[paths[i][j]]) > thresh:
        neg_nodes_set.add(bc_nuclear_receptors[paths[i][j]])
      else:
        neutral_nodes.add(bc_nuclear_receptors[paths[i][j]])
    else:
      if abs(corr_list[paths[i][j]]) > thresh:
        pos_nodes_set.add(bc_nuclear_receptors[paths[i][j]])
      else:
        neutral_nodes.add(bc_nuclear_receptors[paths[i][j]])
    if corr_list[paths[i][j+1]] < 0:
      if abs(corr_list[paths[i][j+1]]) > thresh:
        neg_nodes_set.add(bc_nuclear_receptors[paths[i][j+1]])
      else:
        neutral_nodes.add(bc_nuclear_receptors[paths[i][j+1]])
    else:
      if abs(corr_list[paths[i][j+1]]) > thresh:
        pos_nodes_set.add(bc_nuclear_receptors[paths[i][j+1]])
      else:
        neutral_nodes.add(bc_nuclear_receptors[paths[i][j+1]])

for layer, nodes in enumerate(nx.topological_generations(G)):
    # `multipartite_layout` expects the layer as a node attribute, so add the
    # numeric layer value as a node attribute
    for node in nodes:
        G.nodes[node]["layer"] = layer

# Compute the multipartite_layout using the "layer" node attribute
pos = nx.multipartite_layout(G, subset_key="layer")
fig, ax = plt.subplots()
#nx.draw_networkx(G, pos=pos, ax=ax, node_size=2500, node_color='y', alpha=0.5)
nx.draw_networkx_edges(G, pos=pos, edgelist=neg_edge_list, arrowstyle='-[', node_size=2000)
nx.draw_networkx_edges(G, pos=pos, edgelist=pos_edge_list, node_size=2000)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(pos_nodes_set), node_size=2000, node_color='g', node_shape='o', alpha=0.5)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(neg_nodes_set), node_size=2000, node_color='r', node_shape='o', alpha=0.5)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(neutral_nodes), node_size=2000, node_color='grey', node_shape='o', alpha=0.35)
nx.draw_networkx_labels(G, pos)
ax.set_title("Potential pathways for metastasis")
fig.tight_layout()
plt.show()
# fig.savefig('pathways_age_brca_tcga_2012.png', dpi=400)

import networkx as nx
import matplotlib.pyplot as plt

G = nx.DiGraph()
neg_edge_list=[]
pos_edge_list=[]
neg_nodes_set=set()
pos_nodes_set=set()
neutral_nodes=set()
thresh=0.2
for i in np.arange(min([len(paths),25])):
  for j in np.arange(len(paths[i])-1):
    G.add_edge(rc_nuclear_receptors[paths[i][j]], rc_nuclear_receptors[paths[i][j+1]])
    if rc_B[paths[i][j+1], paths[i][j]] < 0:
      neg_edge_list.append((rc_nuclear_receptors[paths[i][j]], rc_nuclear_receptors[paths[i][j+1]]))
    else:
      pos_edge_list.append((rc_nuclear_receptors[paths[i][j]], rc_nuclear_receptors[paths[i][j+1]]))
    if corr_list[paths[i][j]] < 0:
      if abs(corr_list[paths[i][j]]) > thresh:
        neg_nodes_set.add(rc_nuclear_receptors[paths[i][j]])
      else:
        neutral_nodes.add(rc_nuclear_receptors[paths[i][j]])
    else:
      if abs(corr_list[paths[i][j]]) > thresh:
        pos_nodes_set.add(rc_nuclear_receptors[paths[i][j]])
      else:
        neutral_nodes.add(rc_nuclear_receptors[paths[i][j]])
    if corr_list[paths[i][j+1]] < 0:
      if abs(corr_list[paths[i][j+1]]) > thresh:
        neg_nodes_set.add(rc_nuclear_receptors[paths[i][j+1]])
      else:
        neutral_nodes.add(rc_nuclear_receptors[paths[i][j+1]])
    else:
      if abs(corr_list[paths[i][j+1]]) > thresh:
        pos_nodes_set.add(rc_nuclear_receptors[paths[i][j+1]])
      else:
        neutral_nodes.add(rc_nuclear_receptors[paths[i][j+1]])

for layer, nodes in enumerate(nx.topological_generations(G)):
    # `multipartite_layout` expects the layer as a node attribute, so add the
    # numeric layer value as a node attribute
    for node in nodes:
        G.nodes[node]["layer"] = layer

# Compute the multipartite_layout using the "layer" node attribute
pos = nx.multipartite_layout(G, subset_key="layer")
fig, ax = plt.subplots()
#nx.draw_networkx(G, pos=pos, ax=ax, node_size=2500, node_color='y', alpha=0.5)
nx.draw_networkx_edges(G, pos=pos, edgelist=neg_edge_list, arrowstyle='-[', node_size=2000)
nx.draw_networkx_edges(G, pos=pos, edgelist=pos_edge_list, node_size=2000)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(pos_nodes_set), node_size=2000, node_color='g', node_shape='o', alpha=0.5)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(neg_nodes_set), node_size=2000, node_color='r', node_shape='o', alpha=0.5)
nx.draw_networkx_nodes(G, pos=pos, nodelist=list(neutral_nodes), node_size=2000, node_color='grey', node_shape='o', alpha=0.35)
nx.draw_networkx_labels(G, pos)
ax.set_title("Potential pathways for metastasis")
fig.tight_layout()
plt.show()
# fig.savefig('pathways_age_brca_tcga_2012.png', dpi=400)

"""Cyclin ordering verification

**Rectal adenocarcinoma cancer data Nature 2012**
"""

from google.colab import drive
drive.mount('/content/drive',force_remount=True)
import os
os.chdir("drive/My Drive/cbio_data")
!ls

import numpy as np
import pandas as pd
file_name = 'colon_data_mrna_agilent_microarray.txt'
rc_df = pd.read_csv(file_name,sep='\t',header=(0))

file_name = 'colon_data_clinical_patient.txt'
rc_clinical_df = pd.read_csv(file_name,sep='\t',header=(0)).drop(index=[0,1,2,3])

rc_temp=pd.concat([rc_clinical_df['#Patient Identifier'],rc_clinical_df['Primary Tumor Pathologic Spread']], axis=1).reset_index()

# pick column/sample names in the rna-seq data that correspond to reference set
rc_ref_data = rc_temp[rc_temp['Primary Tumor Pathologic Spread']=='T2']
rc_ref_cols = [sub for sub in rc_df.columns[2:].tolist() if sub[0:12] in rc_ref_data['#Patient Identifier'].tolist()]

# pick column/sample names in the rna-seq data that correspond to reference set
rc_path_data = rc_temp[rc_temp['Primary Tumor Pathologic Spread']=='T3']
rc_path_cols = [sub for sub in rc_df.columns[2:].tolist() if sub[0:12] in rc_path_data['#Patient Identifier'].tolist()]

rc_nuclear_receptors = ['AR', 'ESR1', 'ESR2', 'ESRRA', 'ESRRB', 'ESRRG', 'HNF4A', 'HNF4G', 'NR0B1', 'NR0B2', 'NR1D1', 'NR1D2', 'NR1H2', 'NR1H3', 'NR1H4', 'NR1I2', 'NR1I3', 'NR2C1', 'NR2C2', 'NR2E1', 'NR2E3', 'NR2F1', 'NR2F2', 'NR2F6', 'NR3C1', 'NR3C2', 'NR4A1', 'NR4A2', 'NR4A3', 'NR5A1', 'NR5A2', 'NRF1', 'PGR', 'PPARA', 'PPARD', 'PPARG', 'RARA', 'RARB', 'RARG', 'RORA', 'RORB', 'RORC', 'RXRA', 'RXRB', 'RXRG', 'THRA', 'THRB', 'VDR']

rc_selected_rows = [item for sublist in [rc_df[rc_df['Hugo_Symbol']==e].index.to_list() for e in rc_nuclear_receptors] for item in sublist]

#add indices for ccna1 and ccnd1 if not present already
rc_selected_rows.append(5491)
rc_selected_rows.append(15765)

# reference dataframe

rc_filtered_ref_df=rc_df[rc_ref_cols].iloc[rc_selected_rows]

# pathological dataframe

rc_filtered_path_df=rc_df[rc_path_cols].iloc[rc_selected_rows]

rc_filtered_ref_df.index.get_indexer(rc_df.index[rc_df['Hugo_Symbol']=='CCNA1'])

rc_filtered_ref_df.index.get_indexer(rc_df.index[rc_df['Hugo_Symbol']=='CCND1'])

rc_ref_rna_seq = rc_filtered_ref_df[rc_filtered_ref_df.columns].T.values.tolist()
rc_path_rna_seq = rc_filtered_path_df[rc_filtered_path_df.columns].T.values.tolist()

rc_ccna_pos=len(rc_selected_rows)-2;
rc_ccnd_pos=len(rc_selected_rows)-1;
def SortByStage(list_):
  cell_age = 100*list_[rc_ccna_pos] - 10*list_[rc_ccnd_pos]
  return cell_age;

rc_ref_rna_seq.sort(key=SortByStage)
rc_path_rna_seq.sort(key=SortByStage)

# compute covariance matrix for ref and path rna seq data
R=list(map(list, zip(*rc_ref_rna_seq)))
rc_Sigma_ref = np.cov(R, bias=True)
R=list(map(list, zip(*rc_path_rna_seq)))
rc_Sigma_path = np.cov(R, bias=True)

rc_Diffusivity=ComputeDiffusivity(rc_ref_rna_seq)

rc_A = SolveSensingProblem(rc_Sigma_ref, rc_Diffusivity, noise_level=0.1)

import seaborn as sn
import matplotlib.pyplot as plt

plt.figure(figsize=(20, 20))
colormap=sn.color_palette("Spectral", as_cmap=True)
A_dim = rc_A.shape[0]-2
hm = sn.heatmap(data = rc_A[0:A_dim,0:A_dim], linewidths=.05,cmap=colormap)
hm.set_xticklabels(rc_df['Hugo_Symbol'].iloc[rc_filtered_ref_df.index][0:A_dim], rotation = 90)
hm.set_yticklabels(rc_df['Hugo_Symbol'].iloc[rc_filtered_ref_df.index][0:A_dim], rotation = 0)

# displaying the plotted heatmap
plt.show()

rc_C = rc_Sigma_path - rc_Sigma_ref
rc_B=ComputeCanonicalPerturbation(rc_A, rc_C, rc_Sigma_ref, epsilon=0.1, noise_level=0.2)

import seaborn as sn
import matplotlib.pyplot as plt

plt.figure(figsize=(20, 20))
colormap=sn.color_palette("Spectral", as_cmap=True)
B_dim = rc_B.shape[0]-2
hm = sn.heatmap(data = 0.1*rc_B[0:B_dim,0:B_dim], linewidths=.05,cmap=colormap)
hm.set_xticklabels(rc_df['Hugo_Symbol'].iloc[rc_filtered_ref_df.index][0:B_dim], rotation = 90)
hm.set_yticklabels(rc_df['Hugo_Symbol'].iloc[rc_filtered_ref_df.index][0:B_dim], rotation = 0)
# displaying the plotted heatmap
plt.show()

bc_nrs = set(bc_df['Hugo_Symbol']).intersection(set(bc_nuclear_receptors))
rc_nrs = set(rc_df['Hugo_Symbol']).intersection(set(rc_nuclear_receptors))
print(len(bc_nrs),len(rc_nrs))
print(bc_nrs - rc_nrs)

"""**Basket trial candidates**"""

import itertools

def generate_hamming_weight_k_vectors(n=50, k=2):
  if n < k:
   return []
  vectors = []
  # Iterate through all combinations of 3 positions for the '1's
  for ones_positions in itertools.combinations(range(n), k):
    vector_list = np.zeros(n)
    for pos in ones_positions:
      vector_list[pos] = 1
    vectors.append(vector_list)
  return vectors

epsilon_bc = 0.01
epsilon_rc = 0.1
N = 48
delta_base = (bc_A+bc_A.T)[0:N,0:N]-(rc_A+rc_A.T)[0:N,0:N]
delta_pert = epsilon_bc*(bc_B+bc_B.T)[0:N,0:N]-epsilon_rc*(rc_B+rc_B.T)[0:N,0:N]
hamming_weight_k_vectors = generate_hamming_weight_k_vectors(N,2)
gene_pos = np.zeros((N,N))
for v in hamming_weight_k_vectors:
  P = np.diag(v)
  x1, x2 = np.linalg.eigh(P@(delta_base+delta_pert)@P)
  y1, y2 = np.linalg.eigh(P@(delta_base)@P)
  if np.max(y1)<0.5 or x1[-1]==0.0:
    continue
  print(x1[-1], y1[-1])
  r = y1[-1]/(0.01+x1[-1])
  ones_index = [i for i, val in enumerate(v) if val == 1]
  gene_pos[ones_index[0],ones_index[1]]+=r
  gene_pos[ones_index[1],ones_index[0]]+=r

plt.figure(figsize=(20, 20))
colormap=sn.color_palette("Spectral", as_cmap=True)
colormap=sn.color_palette("Greys", as_cmap=True)
hm = sn.heatmap(data = gene_pos, linewidths=.05,cmap=colormap)
hm.set_xticklabels(bc_nuclear_receptors, rotation = 90)
hm.set_yticklabels(bc_nuclear_receptors, rotation = 0)
# displaying the plotted heatmap
plt.show()

epsilon_bc = 0.01
epsilon_rc = 0.1
N = 48
delta_base = (bc_A+bc_A.T)[0:N,0:N]-(rc_A+rc_A.T)[0:N,0:N]
delta_pert = epsilon_bc*(bc_B+bc_B.T)[0:N,0:N]-epsilon_rc*(rc_B+rc_B.T)[0:N,0:N]
ratios = []
diffs = []
alpha=1
for k in [1,2,3,4,5,N-4,N-3,N-2,N-1,N]:
  rmax = 0
  dmin = 10000
  hamming_weight_k_vectors = generate_hamming_weight_k_vectors(N,k)
  for v in hamming_weight_k_vectors:
    P = np.diag(v)
    x1, x2 = np.linalg.eigh(P@(delta_base+delta_pert)@P)
    y1, y2 = np.linalg.eigh(P@(delta_base)@P)
    if np.max(y1)<0.25 or x1[-1]==0.0:
      continue
    rmax = max(rmax, y1[-1]/(0.01+x1[-1]))
    dmin = min(dmin,x1[-1]-alpha*y1[-1])
  ratios.append(rmax)
  diffs.append(dmin)

print(diffs)

pip install brokenaxes

from brokenaxes import brokenaxes

# Create the broken axes object
fig = plt.figure(figsize=(6, 4))
bax = brokenaxes(xlims=((1,5), (44,48)), hspace=0.1)

# Plot on the broken axes
#plt.plot(np.arange(len(ratios)),np.sort(ratios)[::-1])
bax.plot(np.arange(1,6), ratios[0:5], color='black') # label='Series 1')
bax.plot(np.arange(44,49), ratios[5:], color='black') # label='Series 2')

# Add labels and a legend
#bax.set_title("Max eigenvalue vs group size")
bax.set_xlabel("group size")
bax.set_ylabel("inverse max eigenvalue")
# bax.legend()
plt.show()

from brokenaxes import brokenaxes

# Create the broken axes object
fig = plt.figure(figsize=(6, 4))
bax = brokenaxes(xlims=((1,5), (44,48)), hspace=0.1)

# Plot on the broken axes
#plt.plot(np.arange(len(ratios)),np.sort(ratios)[::-1])
bax.plot(np.arange(1,6), diffs[0:5], color='black') # label='Series 1')
bax.plot(np.arange(44,49), diffs[5:], color='black') # label='Series 2')

# Add labels and a legend
#bax.set_title("Max eigenvalue vs group size")
bax.set_xlabel("group size")
bax.set_ylabel("min-max equilibrium value")
# bax.legend()
plt.show()

"""**scVelo experiment**"""

pip install 'matplotlib<3.7'

pip install -U scvelo

import scvelo as scv

adata = scv.datasets.pancreas()

adata = scv.datasets.dentategyrus()

scv.pp.filter_genes(adata, min_shared_counts=20)

scv.pp.normalize_per_cell(adata)
scv.pp.neighbors(adata, n_neighbors=10)
scv.pp.moments(adata, n_neighbors=10)
scv.tl.recover_dynamics(adata)
scv.tl.latent_time(adata)

mus_nuclear_receptors = ['Ar', 'Esr1', 'Esr2', 'Esrra', 'Esrrb', 'Esrrg', 'Hnf4a', 'Hnf4g', 'Nr0b1', 'Nr0b2', 'Nr1d1', 'Nr1d2', 'Nr1h2', 'Nr1h3', 'Nr1h4', 'Nr1i2', 'Nr1i3', 'Nr2c1', 'Nr2c2', 'Nr2e1', 'Nr2e3', 'Nr2f1', 'Nr2f2', 'Nr2f6', 'Nr3c1', 'Nr3c2', 'Nr4a1', 'Nr4a2', 'Nr4a3', 'Nr5a1', 'Nr5a2', 'Nr6a1', 'Nrf1', 'Pgr', 'Ppara', 'Ppard', 'Pparg', 'Rara', 'Rarb', 'Rarg', 'Rora', 'Rorb', 'Rorc', 'Rxra', 'Rxrb', 'Rxrg', 'Thra', 'Thrb', 'Vdr']

# cluster_name = 'Beta'
cluster_name = 'Microglia'
beta_cells = adata.obs['clusters'] == cluster_name

def SortByLatentTime(list_):
    return list_[len(list_)-1];

Y=np.c_[adata[beta_cells, list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors))].X.toarray(), adata[beta_cells, list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors))].obs['latent_time'].to_numpy()]
Z=Y.tolist()
Z.sort(key=SortByLatentTime)
D_Z=ComputeDiffusivity(Z)

import matplotlib.pyplot as plt
import seaborn as sn

plt.figure(figsize=(10, 10))
colormap=sn.color_palette("Spectral", as_cmap=True)
hm = sn.heatmap(data = D_Z[0:len(D_Z)-1,0:len(D_Z)-1], linewidths=.05,cmap=colormap)
hm.set_xticklabels(list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors)), rotation = 90)
hm.set_yticklabels(list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors)), rotation = 0)
# displaying the plotted heatmap
# plt.show()
from pylab import savefig
figure = hm.get_figure()
figure.savefig('diffusivity_microglia_latent_time.png', dpi=400)

# assumes input is a list of lists with column 0 being the sample ids and
#column nos.; ccna_pos, ccnd_pos being the indices of ccna1 and ccnd1
ccne_pos=7;
ccnd_pos=8;
def SortByStage(list_):
    cell_age = 100*list_[ccne_pos] - 10*list_[ccnd_pos]
    return cell_age;

Y=np.c_[adata[beta_cells, list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors))].X.toarray(), adata[beta_cells, ['Ccnl1', 'Ccnd2']].X.toarray()]
Z=Y.tolist()
Z.sort(key=SortByStage)
approxD_Z=ComputeDiffusivity(Z)

import matplotlib.pyplot as plt
import seaborn as sn

plt.figure(figsize=(10, 10))
colormap=sn.color_palette("Spectral", as_cmap=True)
hm = sn.heatmap(data = approxD_Z[0:len(D_Z)-1,0:len(D_Z)-1], linewidths=.05,cmap=colormap)
hm.set_xticklabels(list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors)), rotation = 90)
hm.set_yticklabels(list(set(adata.var.index.to_list()) & set(mus_nuclear_receptors)), rotation = 0)
# displaying the plotted heatmap
# plt.show()
from pylab import savefig
figure = hm.get_figure()
figure.savefig('diffusivity_microglia_cyclins.png', dpi=400)

"""**Synthetic data experiment**"""

import numpy as np

dim = 10
A = np.identity(dim)
B = -1*np.identity(dim) + np.random.normal(np.zeros((dim, dim)), 0.01*A)
x0 = np.random.normal(np.zeros(A.shape), 0.01*A)
X = x0
xprev = x0
for i in np.arange(1000):
  xi = 0.01*(B@xprev) + np.random.normal(np.zeros(A.shape), 0.01*A)
  xprev += xi
  X = np.c_[X, xi]

def IntroduceInversions(Z, k):
  for i in np.arange(k):
    c = np.random.choice(np.arange(Z.shape[1]), 2)
    Z[:,[c[1],c[0]]] = Z[:,[c[0],c[1]]]
  return Z;

def ComputeCoVarianceOfIncrements(X):
  Xlist = X.T.tolist()
  return ComputeDiffusivity(Xlist);

def ComputeCovarianceAfterPert(X, num_inversions = 10):
  Xpermuted = X
  Sigma = []
  Sigma.append(ComputeCoVarianceOfIncrements(X))
  Xpermuted = IntroduceInversions(Xpermuted, num_inversions)
  Sigma.append(ComputeCoVarianceOfIncrements(Xpermuted))
  return Sigma

from numpy import linalg as npla
import matplotlib.pyplot as plt

# plot and compare Sigma1 and Sigma2 (after normalization as a function of number of inversions)
num_inversions_list = []
norm_list = []
Sigma = []
for k in np.arange(100):
  Sigma = ComputeCovarianceAfterPert(X, k)
  norm_list.append(npla.norm(Sigma[1]-Sigma[0]))
  num_inversions_list.append(k)
plt.plot(num_inversions_list, norm_list)
plt.ylabel("Forbenius norm of difference")  # add X-axis label
plt.xlabel("number of inversions")  # add Y-axis label
plt.title("Error vs number of inversions")  # add title
#plt.show()
plt.savefig('frob_norm_inv.pdf', transparent=False, bbox_inches='tight', dpi=512)

"""Misc scratch"""

np.where(np.isinf(filtered_ref_df))

from numpy import inf
filtered_path_df[filtered_path_df == -inf] = -10

rc_df[rc_df['Hugo_Symbol'].str.contains("GCNF")]

import numpy as np

cyclins = list(zip(list(df.columns)[2:],np.log(df[df['Hugo_Symbol']=='CCNA1'].iloc[:,2:].values).flatten().tolist(), np.log(df[df['Hugo_Symbol']=='CCNG1'].iloc[:,2:].values).flatten().tolist(), np.log(df[df['Hugo_Symbol']=='CCNI'].iloc[:,2:].values).flatten().tolist(), np.log(df[df['Hugo_Symbol']=='CCND1'].iloc[:,2:].values).flatten().tolist()))

np.corrcoef([row[1] for row in cyclins], [row[2] for row in cyclins])

np.std(df[df['Hugo_Symbol']=='CCND1'].values.flatten()[2:])

# df.loc[df['Hugo_Symbol'].str.contains(r'CCN')==True]
import matplotlib.pyplot as plt

plt.bar(np.arange(len([row[0] for row in cyclins])),[row[4] for row in cyclins])
plt.show()

filtered_ref_df.index

clinical_df[['#Patient Identifier','Overall Survival (Months)']].drop(index=[0,1,2,3])

plt.scatter(np.arange(len(clinical_df[['Overall Survival (Months)']].drop(index=[0,1,2,3]).values.tolist())), clinical_df[['Overall Survival (Months)']].drop(index=[0,1,2,3]).values.tolist())

[s for s in adata.var.index.to_list() if "Ccn" in s]
